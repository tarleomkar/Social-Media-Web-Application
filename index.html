<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Config</title>
</head>
<body>
    <h1>Radda Bhaava!!!</h1>
    <p>
        // 1. Write a program to represent sparse matrix using array and perform 
        // simple and fast transpose
        
        #include <stdio.h>
        
        int main() 
        {
            int numRows, numCols, i, j;
            int sparseMatrix[numRows][numCols];
            // User input
            printf("Enter the number of rows and columns for the sparse matrix: ");
            scanf("%d %d", &numRows, &numCols);
            
        //	Taking elements from user
            printf("Enter the elements of the sparse matrix:\n");
            for( i = 0; i < numRows; i++) {
                for ( j = 0; j < numCols; j++) {
                    scanf("%d", &sparseMatrix[i][j]);
                }
            }
        
            int size = 0;
            for ( i = 0; i < numRows; i++) {
                for ( j = 0; j < numCols; j++) {
                    if (sparseMatrix[i][j] != 0) {
                        size++;
                    }
                }
            }
        
            int compactMatrix[3][size];
        
            int k = 0;
            for ( i = 0; i < numRows; i++) {
                for ( j = 0; j < numCols; j++) {
                    if (sparseMatrix[i][j] != 0) {
                        compactMatrix[0][k] = i;
                        compactMatrix[1][k] = j;
                        compactMatrix[2][k] = sparseMatrix[i][j];
                        k++;
                    }
                }
            }
        
            printf("Original Matrix:\n");
            for ( i = 0; i < 3; i++) {
                for ( j = 0; j < size; j++) {
                    printf("%d ", compactMatrix[i][j]);
                }
                printf("\n");
            }
        
            // Transpose the matrix
            int transposedMatrix[3][size];
        
            for ( i = 0; i < size; i++) {
                transposedMatrix[0][i] = compactMatrix[1][i];
                transposedMatrix[1][i] = compactMatrix[0][i];
                transposedMatrix[2][i] = compactMatrix[2][i];
            }
            
        //	Printing transpose of matrix
            printf("\nTransposed Matrix:\n");
            for ( i = 0; i < 3; i++) {
                for ( j = 0; j < size; j++) {
                    printf("%d ", transposedMatrix[i][j]);
                }
                printf("\n");
            }
        
            // Simple Transpose
            int simpleTransposedMatrix[3][size];
            for ( i = 0; i < size; i++) {
                simpleTransposedMatrix[0][i] = compactMatrix[1][i];
                simpleTransposedMatrix[1][i] = compactMatrix[0][i];
                simpleTransposedMatrix[2][i] = compactMatrix[2][i];
            }
        
            printf("\nSimple Transposed Matrix:\n");
            for ( i = 0; i < 3; i++) {
                for ( j = 0; j < size; j++) {
                    printf("%d ", simpleTransposedMatrix[i][j]);
                }
                printf("\n");
            }
        
            // Fast Transpose
            int fastTransposedMatrix[3][size];
        
            // Initialize arrays for fast transpose
            int rowTerms[numCols];
            int startingPos[numCols];
        
            for ( i = 0; i < numCols; i++) {
                rowTerms[i] = 0;
            }
        
            for ( i = 0; i < size; i++) {
                int col = compactMatrix[1][i];
                rowTerms[col]++;
            }
        
            startingPos[0] = 0;
        
            for ( i = 1; i < numCols; i++) {
                startingPos[i] = startingPos[i - 1] + rowTerms[i - 1];
            }
        
            for ( i = 0; i < size; i++) {
                int col = compactMatrix[1][i];
                int dest = startingPos[col];
        
                fastTransposedMatrix[0][dest] = compactMatrix[1][i];
                fastTransposedMatrix[1][dest] = compactMatrix[0][i];
                fastTransposedMatrix[2][dest] = compactMatrix[2][i];
        
                startingPos[col]++;
            }
        
            printf("\nFast Transposed Matrix:\n");
            for ( i = 0; i < 3; i++) {
                for ( j = 0; j < size; j++) {
                    printf("%d ", fastTransposedMatrix[i][j]);
                }
                printf("\n");
            }
        
            return 0;
        }
        <br><br>
        // 2. Write a menu driven program to perform following operations on singly 
        // linked list: Create, Insert, Delete, reverse, search, count and Display
        #include <stdio.h>
            #include <stdlib.h>
            
            struct node   
            {  
                int data;  
                struct node *next;   
            };
            
            struct node *head = NULL; // Initialize head to NULL
            
            void insert()  
            {  
                struct node *ptr;  
                int item;  
                ptr = (struct node *)malloc(sizeof(struct node));  // Corrected allocation size
                if(ptr == NULL)  
                {  
                    printf("\nOVERFLOW\n");  
                }  
                else  
                {  
                    printf("\nEnter value:\n");    
                    scanf("%d", &item);    
                    ptr->data = item;  
                    ptr->next = head;  
                    head = ptr;  
                    printf("\nNode inserted\n");  
                }  
            }  
            
            void delete()  
            {  
                struct node *ptr;  
                if(head == NULL)  
                {  
                    printf("\nList is empty\n");  
                }  
                else   
                {  
                    ptr = head;  
                    head = ptr->next;  
                    free(ptr);  
                    printf("\nNode deleted from the beginning\n");  
                }  
            }
            
            void reverse()
            {
                struct node *prev = NULL;
                struct node *current = head;
                struct node *next = NULL;
            
                while (current != NULL) {
                    next = current->next;
                    current->next = prev;
                    prev = current;
                    current = next;
                }
                head = prev;
            }
            
            void search()  
            {  
                struct node *ptr;  
                int item,i=0,flag;  
                ptr = head;   
                if(ptr == NULL)  
                {  
                    printf("\nEmpty List\n");  
                }  
                else  
                {   
                    printf("\nEnter item which you want to search?\n");   
                    scanf("%d",&item);  
                    while (ptr!=NULL)  
                    {  
                        if(ptr->data == item)  
                        {  
                            printf("item found at location %d ",i+1);  
                            flag=0;  
                        }   
                        else  
                        {  
                            flag=1;  
                        }  
                        i++;  
                        ptr = ptr -> next;  
                    }  
                    if(flag==1)  
                    {  
                        printf("Item not found\n");  
                    }  
                }      
            } 
            
            void count()
            {
                struct node* current = head;
                int count = 0;
                while (current != NULL) {
                    count++;
                    current = current->next;
                }
                printf("Total nodes are: %d\n", count);
            }
            
            void display()  
            {  
                struct node *ptr;  
                ptr = head;   
                if(ptr == NULL)  
                {  
                    printf("Nothing to print");  
                }  
                else  
                {  
                    printf("\nprinting values . . . . .\n");   
                    while (ptr!=NULL)  
                    {  
                        printf("\n%d",ptr->data);  
                        ptr = ptr -> next;  
                    }  
                }  
            }     
            
            int main()  
            {  
                int choice = 0;  
                while(choice != 7)   
                {  
                    printf("\n*********Main Menu*********\n");  
                    printf("\n Choose one option from the following list ...\n");  
                    printf("\n =============================================== \n");  
                    printf("\n 1. Insert");
                    printf("\n 2. Delete");
                    printf("\n 3. Reverse");
                    printf("\n 4. Search");
                    printf("\n 5. count");
                    printf("\n 6. display");
                    printf("\nEnter your choice?\n");         
                    scanf("%d", &choice);  
                    switch(choice)  
                    {  
                        case 1:  
                            insert();      
                            break;
                        case 2:
                            delete();
                            break;
                        case 3:
                            reverse();
                            printf("\nList reversed\n");
                            break;
                        case 4:
                            search();
                            break;
                        case 5:
                            count();
                            break;
                        case 6:
                            display();
                            break;
                        case 7:
                            exit(0);
                            break;  
                        default:  
                            printf("Please enter valid choice..\n");  
                    }  
                }
                return 0;
            }  
            <br><br>
            /*3.Write a menu driven program which will maintain a list of car models, 
            their price, name of the manufacture, engine capacity etc. as a doubly 
            linked list. The menu should make provisions for inserting information 
            pertaining to new car models, delete obsolete models, update data such as 
            price besides answering queries such as listing all car models within a 
            price range specified by the client and listing all details given a car model*/
            #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                
                typedef struct Car {
                    char *model;
                    float price;
                    char *manufacturer;
                    float engineCapacity;
                    struct Car *prev;
                    struct Car *next;
                } Car;
                
                Car* createCar(char *model, float price, char *manufacturer, float engineCapacity) {
                    Car* newCar = (Car*)malloc(sizeof(Car));
                    newCar->model = strdup(model);
                    newCar->price = price;
                    newCar->manufacturer = strdup(manufacturer);
                    newCar->engineCapacity = engineCapacity;
                    newCar->prev = NULL;
                    newCar->next = NULL;
                    return newCar;
                }
                
                void insertCar(Car **head, char *model, float price, char *manufacturer, float engineCapacity) {
                    Car* newCar = createCar(model, price, manufacturer, engineCapacity);
                
                    if (*head == NULL) {
                        *head = newCar;
                        return;
                    }
                
                    Car* temp = *head;
                    while (temp->next != NULL) {
                        temp = temp->next;
                    }
                
                    temp->next = newCar;
                    newCar->prev = temp;
                }
                
                void displayCars(Car *head) {
                    if (head == NULL) {
                        printf("No cars available.\n");
                        return;
                    }
                
                    printf("Car Details:\n");
                    while (head != NULL) {
                        printf("Model: %s, Price: %.2f, Manufacturer: %s, Engine Capacity: %.2f\n",
                               head->model, head->price, head->manufacturer, head->engineCapacity);
                        head = head->next;
                    }
                }
                
                // Add other operations like delete, update, search within price range etc.
                
                int main() {
                    Car* head = NULL;
                    int choice;
                    char model[50], manufacturer[50];
                    float price, engineCapacity;
                
                    do {
                        printf("\nMenu:\n");
                        printf("1. Insert a new car\n");
                        printf("2. Display all cars\n");
                        printf("3. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter model: ");
                                scanf("%s", model);
                                printf("Enter price: ");
                                scanf("%f", &price);
                                printf("Enter manufacturer: ");
                                scanf("%s", manufacturer);
                                printf("Enter engine capacity: ");
                                scanf("%f", &engineCapacity);
                                insertCar(&head, model, price, manufacturer, engineCapacity);
                                break;
                
                            case 2:
                                displayCars(head);
                                break;
                
                            case 3:
                                printf("Exiting the program.\n");
                                break;
                
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    } while (choice != 3);
                
                    // Free memory before exiting
                    while (head != NULL) {
                        Car* temp = head;
                        head = head->next;
                        free(temp->model);
                        free(temp->manufacturer);
                        free(temp);
                    }
                
                    return 0;
                }
                <br><br>
            /*4.Write a program to implement stack as an ADT. Use this ADT to perform 
            expression conversion and evaluation. (Infix â€“ Postfix) */
            #include <stdio.h>
                #include <stdlib.h>
                #define MAX 20
                
                char stack[MAX];
                int top = -1;
                
                int isEmpty() {
                    return top == -1;
                }
                
                int isFull() {
                    return top == MAX - 1;
                }
                
                char peek() {
                    return stack[top];
                }
                
                char pop() {
                    if (isEmpty())
                        return -1;
                    return stack[top--];
                }
                
                void push(char operand) {
                    if (isFull()) {
                        printf("Stack Full!!!!");
                        return;
                    }
                    stack[++top] = operand;
                }
                
                int isOperand(char character) {
                    return (character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z');
                }
                
                int precedence(char operator) {
                    switch (operator) {
                        case '+':
                        case '-':
                            return 1;
                
                        case '*':
                        case '/':
                            return 2;
                
                        case '^':
                            return 3;
                    }
                    return -1;
                }
                
                void infixToPostfix(char *expression) {
                    int i, j;
                
                    for (i = 0, j = -1; expression[i]; ++i) {
                        if (isOperand(expression[i]))
                            expression[++j] = expression[i];
                
                        else if (expression[i] == '(')
                            push(expression[i]);
                
                        else if (expression[i] == ')') {
                            while (!isEmpty() && peek() != '(')
                                expression[++j] = pop();
                
                            if (!isEmpty() && peek() != '(')
                                return; // Error: Unbalanced parentheses
                            else
                                pop(); // Discard '('
                        } else {
                            while (!isEmpty() && precedence(expression[i]) <= precedence(peek()))
                                expression[++j] = pop();
                            push(expression[i]);
                        }
                    }
                
                    while (!isEmpty())
                        expression[++j] = pop();
                
                    expression[++j] = '\0';
                    printf("Postfix Expression: %s\n", expression);
                }
                
                void displayMenu() {
                    printf("\nMenu:\n");
                    printf("1. Convert Infix to Postfix\n");
                    printf("2. Exit\n");
                }
                
                int main() {
                    int choice;
                    char expression[MAX];
                
                    do {
                        displayMenu();
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                        getchar(); // Clear newline from input buffer
                
                        switch (choice) {
                            case 1:
                                printf("Enter the Infix expression: ");
                                fgets(expression, sizeof(expression), stdin);
                                expression[strcspn(expression, "\n")] = '\0'; // Remove newline character from input
                                infixToPostfix(expression);
                                break;
                            case 2:
                                printf("Exiting the program.\n");
                                break;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    } while (choice != 2);
                
                    return 0;
                }
                <br><br>
                /*5.Write a program to implement circular queue using arrays*/
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    #define MAX_SIZE 5
                    
                    struct CircularQueue {
                        int front, rear;
                        int array[MAX_SIZE];
                    };
                    
                    void initializeQueue(struct CircularQueue* queue) {
                        queue->front = queue->rear = -1;
                    }
                    
                    int isEmpty(struct CircularQueue* queue) {
                        return (queue->front == -1 && queue->rear == -1);
                    }
                    
                    int isFull(struct CircularQueue* queue) {
                        return ((queue->rear + 1) % MAX_SIZE == queue->front);
                    }
                    
                    void enqueue(struct CircularQueue* queue, int value) {
                        if (isFull(queue)) {
                            printf("Queue is full. Cannot enqueue %d.\n", value);
                            return;
                        }
                    
                        if (isEmpty(queue)) {
                            queue->front = 0;
                        }
                    
                        queue->rear = (queue->rear + 1) % MAX_SIZE;
                        queue->array[queue->rear] = value;
                    
                        printf("%d enqueued to the queue.\n", value);
                    }
                    
                    int dequeue(struct CircularQueue* queue) {
                        int value;
                    
                        if (isEmpty(queue)) {
                            printf("Queue is empty. Cannot dequeue.\n");
                            return -1;
                        }
                    
                        value = queue->array[queue->front];
                    
                        if (queue->front == queue->rear) {
                            queue->front = queue->rear = -1;
                        } else {
                            queue->front = (queue->front + 1) % MAX_SIZE;
                        }
                    
                        return value;
                    }
                    
                    void display(struct CircularQueue* queue) {
                        int i;
                    
                        if (isEmpty(queue)) {
                            printf("Queue is empty.\n");
                            return;
                        }
                    
                        printf("Elements in the queue: ");
                        i = queue->front;
                        do {
                            printf("%d ", queue->array[i]);
                            i = (i + 1) % MAX_SIZE;
                        } while (i != (queue->rear + 1) % MAX_SIZE);
                        printf("\n");
                    }
                    
                    int main() {
                        struct CircularQueue queue;
                        initializeQueue(&queue);
                    
                        int choice, value;
                    
                        do {
                            printf("\nMenu:\n");
                            printf("1. Enqueue\n");
                            printf("2. Dequeue\n");
                            printf("3. Display\n");
                            printf("4. Exit\n");
                            printf("Enter your choice: ");
                            scanf("%d", &choice);
                    
                            switch (choice) {
                                case 1:
                                    printf("Enter a value to enqueue: ");
                                    scanf("%d", &value);
                                    enqueue(&queue, value);
                                    break;
                    
                                case 2:
                                    value = dequeue(&queue);
                                    if (value != -1) {
                                        printf("Dequeued element: %d\n", value);
                                    }
                                    break;
                    
                                case 3:
                                    display(&queue);
                                    break;
                    
                                case 4:
                                    printf("Exiting program.\n");
                                    break;
                    
                                default:
                                    printf("Invalid choice. Please enter a valid option.\n");
                            }
                    
                        } while (choice != 4);
                    
                        return 0;
                    }
                    <br><br>
                    /*6.Write a program to create binary tree. Find height of the tree and print leaf 
                    nodes. Find mirror image, print original and mirror image using level-wise 
                    printing*/

                    #include <stdio.h>
                        #include <stdlib.h>
                        
                        struct Node {
                            int data;
                            struct Node* left;
                            struct Node* right;
                        };
                        
                        struct Node* createNode(int value) {
                            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                            newNode->data = value;
                            newNode->left = newNode->right = NULL;
                            return newNode;
                        }
                        
                        int max(int a, int b) {
                            return (a > b) ? a : b;
                        }
                        
                        int height(struct Node* root) {
                            if (root == NULL) {
                                return 0;
                            }
                            int leftHeight = height(root->left);
                            int rightHeight = height(root->right);
                            return 1 + max(leftHeight, rightHeight);
                        }
                        
                        void printLeafNodes(struct Node* root) {
                            if (root == NULL) {
                                return;
                            }
                            if (root->left == NULL && root->right == NULL) {
                                printf("%d ", root->data);
                            }
                            printLeafNodes(root->left);
                            printLeafNodes(root->right);
                        }
                        
                        void mirrorImage(struct Node* root) {
                            if (root == NULL) {
                                return;
                            }
                        
                            struct Node* temp = root->left;
                            root->left = root->right;
                            root->right = temp;
                        
                            mirrorImage(root->left);
                            mirrorImage(root->right);
                        }
                        
                        void printLevelOrder(struct Node* root) {
                            if (root == NULL) {
                                return;
                            }
                        
                            struct Node* queue[100];
                            int front = 0, rear = 0;
                            queue[rear++] = root;
                        
                            while (front < rear) {
                                struct Node* current = queue[front++];
                        
                                printf("%d ", current->data);
                        
                                if (current->left != NULL) {
                                    queue[rear++] = current->left;
                                }
                                if (current->right != NULL) {
                                    queue[rear++] = current->right;
                                }
                            }
                        }
                        
                        int main() {
                            struct Node* root = createNode(1);
                            root->left = createNode(2);
                            root->right = createNode(3);
                            root->left->left = createNode(4);
                            root->left->right = createNode(5);
                            root->right->left = createNode(6);
                            root->right->right = createNode(7);
                        
                            printf("Height of the tree: %d\n", height(root));
                        
                            printf("Leaf nodes: ");
                            printLeafNodes(root);
                            printf("\n");
                        
                            printf("Original tree (level order): ");
                            printLevelOrder(root);
                            printf("\n");
                        
                            mirrorImage(root);
                        
                            printf("Mirror image of the tree (level order): ");
                            printLevelOrder(root);
                            printf("\n");
                        
                            return 0;
                        }
                        <br><br>
                        /*7.Write a program that reads a list of names and telephone numbers from 
                        user and insert into a BST tree. Once the tree has been built, present the 
                        user with a menu that allows him to search the list for a specified name, 
                        insert new name, delete an existing name or print the entire phone list.*/

                        #include <stdio.h>
                            #include <stdlib.h>
                            #include <string.h>
                            
                            struct Node {
                                char name[50];
                                char phoneNumber[15];
                                struct Node* left;
                                struct Node* right;
                            };
                            
                            struct Node* createNode(char name[], char phoneNumber[]) {
                                struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                                strcpy(newNode->name, name);
                                strcpy(newNode->phoneNumber, phoneNumber);
                                newNode->left = newNode->right = NULL;
                                return newNode;
                            }
                            
                            struct Node* insert(struct Node* root, char name[], char phoneNumber[]) {
                                if (root == NULL) {
                                    return createNode(name, phoneNumber);
                                }
                            
                                int compareResult = strcmp(name, root->name);
                            
                                if (compareResult < 0) {
                                    root->left = insert(root->left, name, phoneNumber);
                                } else if (compareResult > 0) {
                                    root->right = insert(root->right, name, phoneNumber);
                                }
                            
                                return root;
                            }
                            
                            struct Node* search(struct Node* root, char name[]) {
                                if (root == NULL || strcmp(root->name, name) == 0) {
                                    return root;
                                }
                            
                                if (strcmp(name, root->name) < 0) {
                                    return search(root->left, name);
                                }
                            
                                return search(root->right, name);
                            }
                            
                            struct Node* findMin(struct Node* root) {
                                while (root->left != NULL) {
                                    root = root->left;
                                }
                                return root;
                            }
                            
                            struct Node* deleteNode(struct Node* root, char name[]) {
                                if (root == NULL) {
                                    return root;
                                }
                            
                                int compareResult = strcmp(name, root->name);
                            
                                if (compareResult < 0) {
                                    root->left = deleteNode(root->left, name);
                                } else if (compareResult > 0) {
                                    root->right = deleteNode(root->right, name);
                                } else {
                                    if (root->left == NULL) {
                                        struct Node* temp = root->right;
                                        free(root);
                                        return temp;
                                    } else if (root->right == NULL) {
                                        struct Node* temp = root->left;
                                        free(root);
                                        return temp;
                                    }
                            
                                    struct Node* temp = findMin(root->right);
                                    strcpy(root->name, temp->name);
                                    strcpy(root->phoneNumber, temp->phoneNumber);
                            
                                    root->right = deleteNode(root->right, temp->name);
                                }
                            
                                return root;
                            }
                            
                            void printPhoneList(struct Node* root) {
                                if (root != NULL) {
                                    printPhoneList(root->left);
                                    printf("%s: %s\n", root->name, root->phoneNumber);
                                    printPhoneList(root->right);
                                }
                            }
                            
                            int main() {
                                struct Node* root = NULL;
                                int choice;
                                char name[50];
                                char phoneNumber[15];
                            
                                do {
                                    printf("\nMenu:\n");
                                    printf("1. Search\n");
                                    printf("2. Insert\n");
                                    printf("3. Delete\n");
                                    printf("4. Print Phone List\n");
                                    printf("5. Exit\n");
                                    printf("Enter your choice: ");
                                    scanf("%d", &choice);
                            
                                    switch (choice) {
                                        case 1:
                                            printf("Enter name to search: ");
                                            scanf("%s", name);
                                            struct Node* result = search(root, name);
                                            if (result != NULL) {
                                                printf("Phone number: %s\n", result->phoneNumber);
                                            } else {
                                                printf("Name not found in the phone list.\n");
                                            }
                                            break;
                            
                                        case 2:
                                            printf("Enter name to insert: ");
                                            scanf("%s", name);
                                            printf("Enter phone number: ");
                                            scanf("%s", phoneNumber);
                                            root = insert(root, name, phoneNumber);
                                            break;
                            
                                        case 3:
                                            printf("Enter name to delete: ");
                                            scanf("%s", name);
                                            root = deleteNode(root, name);
                                            break;
                            
                                        case 4:
                                            printf("Phone List:\n");
                                            printPhoneList(root);
                                            break;
                            
                                        case 5:
                                            printf("Exiting program.\n");
                                            break;
                            
                                        default:
                                            printf("Invalid choice. Please enter a valid option.\n");
                                    }
                            
                                } while (choice != 5);
                            
                                return 0;
                            }
                            <br><br>
                            /*8.Write a program to create graph, use the map of any city as the graph. 
                            Represent graph using adjacency list/adjacency matrix and perform Depth 
                            First Search and Breadth First Search.*/
                            #include <stdio.h>
                                #include <stdlib.h>
                                #include <stdbool.h>
                                
                                #define MAX_VERTICES 10
                                
                                struct Node {
                                    int dest;
                                    struct Node* next;
                                };
                                
                                struct Graph {
                                    struct Node* head[MAX_VERTICES];
                                };
                                
                                struct Graph* createGraph(int vertices) {
                                    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
                                    for (int i = 0; i < vertices; ++i)
                                        graph->head[i] = NULL;
                                    return graph;
                                }
                                
                                void addEdge(struct Graph* graph, int src, int dest) {
                                    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                                    newNode->dest = dest;
                                    newNode->next = graph->head[src];
                                    graph->head[src] = newNode;
                                }
                                
                                void DFSUtil(struct Graph* graph, int vertex, bool visited[]) {
                                    visited[vertex] = true;
                                    printf("%d ", vertex);
                                
                                    struct Node* temp = graph->head[vertex];
                                    while (temp != NULL) {
                                        if (!visited[temp->dest])
                                            DFSUtil(graph, temp->dest, visited);
                                        temp = temp->next;
                                    }
                                }
                                
                                void DFS(struct Graph* graph, int startVertex) {
                                    bool* visited = (bool*)malloc(MAX_VERTICES * sizeof(bool));
                                    for (int i = 0; i < MAX_VERTICES; ++i)
                                        visited[i] = false;
                                
                                    printf("Depth First Traversal: ");
                                    DFSUtil(graph, startVertex, visited);
                                    printf("\n");
                                    free(visited);
                                }
                                
                                void BFS(struct Graph* graph, int startVertex) {
                                    bool* visited = (bool*)malloc(MAX_VERTICES * sizeof(bool));
                                    for (int i = 0; i < MAX_VERTICES; ++i)
                                        visited[i] = false;
                                
                                    int queue[MAX_VERTICES];
                                    int front = 0, rear = 0;
                                
                                    printf("Breadth First Traversal: ");
                                    visited[startVertex] = true;
                                    queue[rear++] = startVertex;
                                
                                    while (front < rear) {
                                        int currentVertex = queue[front++];
                                        printf("%d ", currentVertex);
                                
                                        struct Node* temp = graph->head[currentVertex];
                                        while (temp != NULL) {
                                            int adjVertex = temp->dest;
                                            if (!visited[adjVertex]) {
                                                visited[adjVertex] = true;
                                                queue[rear++] = adjVertex;
                                            }
                                            temp = temp->next;
                                        }
                                    }
                                    printf("\n");
                                    free(visited);
                                }
                                
                                int main() {
                                    int vertices = 6; // Change this to the number of vertices in your city map
                                    struct Graph* graph = createGraph(vertices);
                                
                                    // Adding edges (representing connections between locations)
                                    addEdge(graph, 0, 1);
                                    addEdge(graph, 0, 2);
                                    addEdge(graph, 1, 3);
                                    addEdge(graph, 1, 4);
                                    addEdge(graph, 2, 4);
                                    addEdge(graph, 3, 4);
                                    addEdge(graph, 3, 5);
                                    addEdge(graph, 4, 5);
                                
                                    int startVertex = 0; // Starting vertex for traversal
                                
                                    DFS(graph, startVertex);
                                    BFS(graph, startVertex);
                                
                                    return 0;
                                }
                                
                                // Depth First Traversal: 0 2 4 5 1 3 
                                // Breadth First Traversal: 0 2 1 4 3 5   
                                <br><br>
                                /*9.Write a program to represent a graph of any city using adjacency matrix 
                                /adjacency list. Nodes should represent the various areas in the city and 
                                links should represent the distance between them. Find the shortest path of 
                                your college from your home using Dijkstra's algorithm*/

#include <stdio.h>
#include <limits.h>

#define MAX_AREAS 10

int minDistance(int distance[], int shortestPathSet[], int numAreas) {
    int min = INT_MAX, minIndex;

    for (int v = 0; v < numAreas; v++) {
        if (shortestPathSet[v] == 0 && distance[v] <= min) {
            min = distance[v];
            minIndex = v;
        }
    }

    return minIndex;
}

void printPath(int parent[], int j) {
    if (parent[j] == -1) {
        return;
    }

    printPath(parent, parent[j]);
    printf(" -> %d", j);
}

void printSolution(int distance[], int parent[], int numAreas, int source, int destination) {
    printf("Shortest Path from %d to %d: %d\n", source, destination, distance[destination]);
    printf("Path: %d", source);
    printPath(parent, destination);
    printf("\n");
}

void dijkstra(int graph[MAX_AREAS][MAX_AREAS], int numAreas, int source, int destination) {
    int distance[MAX_AREAS];
    int shortestPathSet[MAX_AREAS];
    int parent[MAX_AREAS];

    for (int i = 0; i < numAreas; i++) {
        distance[i] = INT_MAX;
        shortestPathSet[i] = 0;
        parent[i] = -1;
    }

    distance[source] = 0;

    for (int count = 0; count < numAreas - 1; count++) {
        int u = minDistance(distance, shortestPathSet, numAreas);
        shortestPathSet[u] = 1;

        for (int v = 0; v < numAreas; v++) {
            if (!shortestPathSet[v] && graph[u][v] && distance[u] != INT_MAX &&
                distance[u] + graph[u][v] < distance[v]) {
                distance[v] = distance[u] + graph[u][v];
                parent[v] = u;
            }
        }
    }

    printSolution(distance, parent, numAreas, source, destination);
}

int main() {
    int numAreas;
    printf("Enter the number of areas in the city: ");
    scanf("%d", &numAreas);

    int graph[MAX_AREAS][MAX_AREAS];

    printf("Enter the adjacency matrix (enter 0 for areas not directly connected):\n");
    for (int i = 0; i < numAreas; i++) {
        for (int j = 0; j < numAreas; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    int source, destination, choice;

    do {
        printf("\nMenu:\n");
        printf("1. Find Shortest Path\n");
        printf("2. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the source area: ");
                scanf("%d", &source);
                printf("Enter the destination area: ");
                scanf("%d", &destination);
                dijkstra(graph, numAreas, source, destination);
                break;

            case 2:
                printf("Exiting program.\n");
                break;

            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }

    } while (choice != 2);

    return 0;
}


// Output
/*
Enter the number of areas in the city: 5
Enter the adjacency matrix (enter 0 for areas not directly connected):
0 2 4 1 0
2 0 0 3 0
4 0 0 1 5
1 3 1 0 0
0 0 5 0 0

Menu:
1. Find Shortest Path
2. Exit
Enter your choice: 1
Enter the source area: 1
Enter the destination area: 4
Shortest Path from 1 to 4: 4
Path: 1 -> 3 -> 2 -> 4

Menu:
1. Find Shortest Path
2. Exit
Enter your choice: 2
Exiting program.
*/
<br><br>
/*10.Write a program to create student database. Database contains different 
fields of student like Roll No, Name and percentage. Search a particular 
student according to roll number using binary search*/

#include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    struct Student {
        int rollNo;
        char name[50];
        float percentage;
    };
    int i;
    
    int compareStudents(const void* a, const void* b) {
        return ((struct Student*)a)->rollNo - ((struct Student*)b)->rollNo;
    }
    
    int binarySearch(struct Student students[], int left, int right, int targetRollNo) {
        if (right >= left) {
            int mid = left + (right - left) / 2;
            if (students[mid].rollNo == targetRollNo)
                return mid;
            if (students[mid].rollNo > targetRollNo)
                return binarySearch(students, left, mid - 1, targetRollNo);
            return binarySearch(students, mid + 1, right, targetRollNo);
        }
        return -1;
    }
    
    void displayStudent(struct Student student) {
        printf("Roll No: %d\n", student.rollNo);
        printf("Name: %s\n", student.name);
        printf("Percentage: %.2f\n", student.percentage);
        printf("\n");
    }
    
    int main() {
        int numStudents;
        printf("Enter the number of students in the database: ");
        scanf("%d", &numStudents);
    
        struct Student students[numStudents];
    
        for ( i = 0; i < numStudents; i++) {
            printf("\nEnter details for student %d:\n", i + 1);
            printf("Roll No: ");
            scanf("%d", &students[i].rollNo);
    
            printf("Name: ");
            scanf("%s", students[i].name);
    
            printf("Percentage: ");
            scanf("%f", &students[i].percentage);
        }
    
        qsort(students, numStudents, sizeof(struct Student), compareStudents);
    
        int targetRollNo, choice;
    
        do {
            printf("\nMenu:\n");
            printf("1. Search Student by Roll No\n");
            printf("2. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
    
            switch (choice) {
                case 1:
                    printf("\nEnter the Roll No to search: ");
                    scanf("%d", &targetRollNo);
                    int index = binarySearch(students, 0, numStudents - 1, targetRollNo);
                    if (index != -1) {
                        printf("\nStudent found!\n");
                        displayStudent(students[index]);
                    } else {
                        printf("\nStudent not found.\n");
                    }
                    break;
    
                case 2:
                    printf("Exiting program.\n");
                    break;
    
                default:
                    printf("Invalid choice. Please enter a valid option.\n");
            }
    
        } while (choice != 2);
    
        return 0;
    }
    <br><br>
/* 11.
Write a program to arrange list of students to find out first ten toppers
from a class using Bubble sort. (refer the student database given in
assignment 10)
*/
#include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    struct Student {
        int rollNo;
        char name[50];
        float percentage;
    };
    int i, j;
    
    void swap(struct Student* a, struct Student* b) {
        struct Student temp = *a;
        *a = *b;
        *b = temp;
    }
    
    void bubbleSort(struct Student students[], int numStudents) {
        for ( i = 0; i < numStudents - 1; i++) {
            for ( j = 0; j < numStudents - i - 1; j++) {
                if (students[j].percentage < students[j + 1].percentage) {
                    swap(&students[j], &students[j + 1]);
                }
            }
        }
    }
    
    void displayTopTen(struct Student students[], int numStudents) {
        printf("\nTop Ten Toppers:\n");
        printf("Roll No\t\tName\t\tPercentage\n");
        for ( i = 0; i < 10 && i < numStudents; i++) {
            printf("%d\t\t%s\t\t%.2f\n", students[i].rollNo, students[i].name, students[i].percentage);
        }
    }
    
    int main() {
        int i, numStudents, choice;
    
        printf("Enter the number of students in the database: ");
        scanf("%d", &numStudents);
    
        struct Student students[numStudents];
    
        for ( i = 0; i < numStudents; i++) {
            printf("\nEnter details for student %d:\n", i + 1);
            printf("Roll No: ");
            scanf("%d", &students[i].rollNo);
    
            printf("Name: ");
            scanf("%s", students[i].name);
    
            printf("Percentage: ");
            scanf("%f", &students[i].percentage);
        }
    
        do {
            printf("\nMenu:\n");
            printf("1. Display Top Ten Toppers\n");
            printf("2. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
    
            switch (choice) {
                case 1:
                    bubbleSort(students, numStudents);
                    displayTopTen(students, numStudents);
                    break;
    
                case 2:
                    printf("Exiting program.\n");
                    break;
    
                default:
                    printf("Invalid choice. Please enter a valid option.\n");
            }
    
        } while (choice != 2);
    
        return 0;
    }
    <br><br>
/*12. Mereg and quick sort code*/
/*
Write a program to implement Merge sort / Quick sort method
*/

#include <stdio.h>

void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
	int j;
    for ( j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;

        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

void printArray(int arr[], int size) {
	int i;
    for ( i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int choice, n, i;

    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements of the array:\n");
    for ( i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    do {
        printf("\nMenu:\n");
        printf("1. Merge Sort\n");
        printf("2. Quick Sort\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                mergeSort(arr, 0, n - 1);
                printf("Sorted array using Merge Sort: ");
                printArray(arr, n);
                break;
            case 2:
                quickSort(arr, 0, n - 1);
                printf("Sorted array using Quick Sort: ");
                printArray(arr, n);
                break;
            case 3:
                printf("Exiting program.\n");
                break;

            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }

    } while (choice != 3);

    return 0;
}

    </p>
</body>
</html>